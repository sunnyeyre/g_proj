#include <vector>
#include <iostream>
#include <fstream>
#include <cmath>
#include "algebra3.h"
#include "FreeImage.h"

#ifdef OSX
#include <GLUT/glut.h>
#include <OpenGL/glu.h>
#else
#include <GL/glut.h>
#include <GL/glu.h>
#endif

#include <time.h>
#include <math.h>

#define PI 3.14159265
#define g 9.80665 // acceleration due to gravity
#define l 4 //length of pendulum

using namespace std;

//******************************************************************
//  Some Classes
//******************************************************************

class Viewport {
public:
	int w,h;
};

class State {
public:
    int angle;
    float velocity;
    State * next;
};

Viewport viewport;
State* initial_state;
State* present_state;

/* some config variables for frames/sec, size of node, init rot angle, etc.*/
float radius = 0.1;
float win_x, win_y, win_z;
float dt = 1.0/50.0;
/***********************************************************************/

void myReshape(int w, int h) {
	glViewport(0,0, (GLsizei) w, (GLsizei) h);// sets the rectangle that will be the window
	glMatrixMode(GL_PROJECTION);
	glLoadIdentity();				// loading the identity matrix for the screen
	gluPerspective(65.0, (GLfloat) w/(GLfloat) h, 1.0, 20.0);
	glMatrixMode(GL_MODELVIEW);
	glLoadIdentity();
	glTranslatef(0.0, 0.0, -5.0);
}

void advanceT(int value) {
    
    present_state = present_state->next;
    glutTimerFunc(5 , advanceT, 0);
    
}

State * takeastep(State * previous_state) {
    
    State * state = new State;
    state->velocity = previous_state->velocity - (g/l) * sin(previous_state->angle * PI / 180.0) * dt;
    state->angle = previous_state->angle + (int) ((180.0/PI) * dt * state->velocity);
    state->next = NULL;
    return state;

}

void buildFrames(){ //builds frames into a cyclic finite state machine

    if(abs((float)present_state->angle - (float)initial_state->angle) < 
       0.0001 && abs(present_state->velocity - initial_state->velocity) < 0.0001 && initial_state->next != NULL) {
        present_state->next = initial_state;
        glutTimerFunc(5 , advanceT, 0);
        return;
    }
    else {
//        printf("angle: %d, velocity: %f\n", present_state->angle, present_state->velocity);    
    
        present_state->next = takeastep(present_state);
        present_state = present_state->next;
        buildFrames();
    }
}

void initScene(){
	glClearColor(1.0f, 1.0f, 1.0f, 0.0f); // Clear to black, fully transparent
	glClearDepth(0.0);
	glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
	
	glTranslatef(0.0, 0.0, -5.0);
	glPushMatrix();
	
    initial_state = new State;
    initial_state->angle = 30;
    initial_state->velocity = 0.0;
    initial_state->next = NULL;
    present_state = initial_state;
    buildFrames();
    
	glColor3f(0.0,0.0,1.0);
	
	glutSolidSphere(radius,20,20);
    
	glPushMatrix();
	glBegin(GL_LINES);
	glVertex3f(0,0,0);
	glVertex3f(0,-2,0);
	glEnd();
	
	glTranslatef(0,-2,0);
	glutSolidSphere(radius,20,20);
	glPopMatrix();
	
	glShadeModel (GL_FLAT);
	
}

void initLights() {
	glEnable(GL_LIGHTING);
	glLightModeli(GL_LIGHT_MODEL_TWO_SIDE, GL_TRUE);
	GLfloat global_ambient[] = {.1f, .1f, .1f};
	glLightModelfv(GL_LIGHT_MODEL_AMBIENT, global_ambient);
	
	GLfloat ambient[] = {0.1f, 0.1f, 0.1f};
	GLfloat diffuse[] = {1.0f, 1.0f, 1.0f};
	GLfloat specular[] = {1.0f, 1.0f, 1.0f};
	GLfloat pos[] = {0, 0, 1, 0};
	glLightfv(GL_LIGHT0, GL_AMBIENT, ambient);
	glLightfv(GL_LIGHT0, GL_DIFFUSE, diffuse);
	glLightfv(GL_LIGHT0, GL_SPECULAR, specular);
	glLightfv(GL_LIGHT0, GL_POSITION, pos);
	glEnable(GL_LIGHT0);
	
	GLfloat mat_specular[] = {1.0, 1.0, 1.0, 1.0};
	GLfloat mat_diffuse[] = {1, 0, 1, 1.0};
	GLfloat mat_ambient[] = {.1, .1, .1, 1.0};
	GLfloat mat_shininess[] = {50.0};
	glMaterialfv(GL_FRONT_AND_BACK, GL_SPECULAR, mat_specular);
	glMaterialfv(GL_FRONT_AND_BACK, GL_AMBIENT, mat_ambient);
	glMaterialfv(GL_FRONT_AND_BACK, GL_DIFFUSE, mat_diffuse);
	glMaterialfv(GL_FRONT_AND_BACK, GL_SHININESS, mat_shininess);
    
	glShadeModel(GL_SMOOTH);
	glEnable(GL_NORMALIZE);
}

void mouseTracker(int button, int state, int x, int y){
	if(button == 0 && state == GLUT_DOWN){
		win_x = (x/viewport.w - 0.5)* 10.0;
		win_y = (viewport.h/2.0 - y) / viewport.h * 10.0;
		win_z = 0.0;
		printf("%d %d, %f %f\n", x, y, win_x, win_y);
		glutPostRedisplay();
	}
}

void myDisplay() {
	glClear(GL_COLOR_BUFFER_BIT);				// clear the color buffer (sets everything to black)
	glViewport(0,0, (GLsizei) viewport.w, (GLsizei) viewport.h);// sets the rectangle that will be the window
	glMatrixMode(GL_PROJECTION);
	glLoadIdentity();				// loading the identity matrix for the screen
	gluPerspective(65.0, (GLfloat) viewport.w/(GLfloat) viewport.h, 1.0, 20.0);
	glMatrixMode(GL_MODELVIEW);
	glLoadIdentity();
    
	glColor3f(0,1,0);
	glTranslatef(0.0, 0.0, -5.0);
    glRotatef(present_state->angle, 0, 0, 1);
	glPushMatrix();

	glColor3f(0.0,0.0,1.0);
	
	glutSolidSphere(radius,20,20);
    
	glPushMatrix();
	glBegin(GL_LINES);
	glVertex3f(0,0,0);
	glVertex3f(0,-2,0);
	glEnd();
	
	glTranslatef(0,-2,0);
	glutSolidSphere(radius,20,20);
	glPopMatrix();
	    
	glShadeModel(GL_FLAT);
	glFlush();
	glutSwapBuffers();					// swap buffers (we earlier set double buffer)
}

void processNormalKeys(unsigned char key, int x, int y) {
    
	if (key == 32) //the space key
		glutPostRedisplay();
    
	if (key == 27) {
        // when receiving the escape key the function escapes
		exit(0);
	}
}

void myFrameMove() {
    
	glutPostRedisplay(); // forces glut to call the display function (myDisplay())
}

int main(int argc, char *argv[]) {
	
    
    FreeImage_Initialise();
    
    
    
    
    
    FreeImage_DeInitialise();
	
  	glutInit(&argc, argv);
  	glutInitDisplayMode(GLUT_DOUBLE | GLUT_RGB);
    
  	viewport.w = 500;
  	viewport.h = 500;
    
  	glutInitWindowSize(viewport.w, viewport.h);
  	glutInitWindowPosition(0, 0);
  	glutCreateWindow("Toy Model");
    
  	initScene();							// quick function to set up scene
	glutSwapBuffers();
	glutDisplayFunc(myDisplay);
    
	glutKeyboardFunc(processNormalKeys);
//	glutSpecialFunc(processSpecialKeys);
  	glutReshapeFunc(myReshape);				// function to run when the window gets resized
  	initLights();
	glEnable(GL_DEPTH_TEST);
	glutMouseFunc(mouseTracker);
	glutIdleFunc(myFrameMove);				// function to run when not handling any other task
	glutMainLoop();							// infinite loop that will keep drawing and resizing and whatever else
    
  	return 0;
}

