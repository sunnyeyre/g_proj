#include <vector>
#include <iostream>
#include <fstream>
#include <cmath>

#ifdef OSX
#include <GLUT/glut.h>
#include <OpenGL/glu.h>
#else
#include <GL/glut.h>
#include <GL/glu.h>
#endif

#include <time.h>
#include <math.h>

#ifdef _WIN32
static DWORD lastTime;
#else
static struct timeval lastTime;
#endif

#define PI 3.14159265

using namespace std;

class Viewport {
public:
	int w, h; // width and height
};

Viewport	viewport;
struct Particle{
	float m;
	float *x;
	float *v;
	float *f;
};
typedef Particle* Particle_t;
struct ParticleSystem{
  Particle_t * p;
	int n;
	float t;
};
ParticleSystem* sys;
float radius = 0.02;
float speed_factor = 2000.0;

void myReshape(int w, int h) {
	viewport.w = w;
	viewport.h = h;
	glViewport(0,0,viewport.w,viewport.h);// sets the rectangle that will be the window
	glMatrixMode(GL_PROJECTION);
	glLoadIdentity();				// loading the identity matrix for the screen
	glOrtho(0, 1, 0, 1, 1, -1);	// resize type = stretch
}

void initScene(){
	glClearColor(1.0f, 1.0f, 1.0f, 0.0f); // Clear to black, fully transparent
	
	myReshape(viewport.w,viewport.h);
}

void myDisplay() {
	glClear(GL_COLOR_BUFFER_BIT);				// clear the color buffer (sets everything to black)
	glMatrixMode(GL_MODELVIEW);					// indicate we are specifying camera transformations
	glLoadIdentity();							// make sure transformation is "zero'd"
glColor3f(0.0,0.0,1.0);
	glPushMatrix();

	for(int i=0; i<sys->n; i++) {
	glTranslatef(sys->p[i]->x[0],sys->p[i]->x[1],0);
	glutSolidSphere(radius,10,10);
	glTranslatef(-sys->p[i]->x[0],-sys->p[i]->x[1],0);
	}
	glPopMatrix();
	glFlush();
	glutSwapBuffers();					// swap buffers (we earlier set double buffer)
}

void processNormalKeys(unsigned char key, int x, int y) {
	if (key == 32) //the space key
		{ 
			float temp_x,temp_y,temp,deltat;
			float temp_x_n[sys->n], temp_y_n[sys->n];
			float temp_t = sys->t;
			sys->t = glutGet(GLUT_ELAPSED_TIME);
			temp_t = (sys->t - temp_t)/speed_factor;

	for(int i=0; i<sys->n; i++){
		temp_x = sys->p[i]->x[0]+sys->p[i]->v[0]*temp_t;
		temp_y = sys->p[i]->x[1]+sys->p[i]->v[1]*temp_t;

  		if(i==0){
	  		temp_x_n[0] = temp_x;
	  		temp_y_n[0] = temp_y;
  		}
	/* collision checking                  */
	for(int j=0; j<i; j++){
		// in case of a collision, return particles to the moment they collide and swap their velocities
		if(((temp_x - temp_x_n[j])*(temp_x - temp_x_n[j])) + ((temp_y - temp_y_n[j])*(temp_y - temp_y_n[j])) <= 4*radius*radius){
			if((temp_x - temp_x_n[j])*(temp_x - temp_x_n[j]) <=4* radius*radius){
				if((sys->p[j]->v[0] - sys->p[i]->v[0])*(sys->p[j]->v[0] - sys->p[i]->v[0]) < 0.000001){
					if(sys->p[i]->x[0] > sys->p[j]->x[0])
						sys->p[j]->v[0]*= -1;
					else
						sys->p[i]->v[0] *= -1;
					deltat = temp_t;
				}
				else {
					if(sys->p[i]->x[0] > sys->p[j]->x[0])
						deltat = (sys->p[i]->x[0] - radius - sys->p[j]->x[0] - radius)/(sys->p[j]->v[0] - sys->p[i]->v[0]);
					else 
						deltat = (sys->p[i]->x[0] + radius - sys->p[j]->x[1] + radius)/(sys->p[j]->v[0] - sys->p[i]->v[0]);
			deltat =deltat<0.0? -deltat:deltat;
				}
			temp_x_n[j] = sys->p[j]->x[0]+sys->p[j]->v[0]*deltat;
			temp_x_n[i] = sys->p[i]->x[0]+sys->p[i]->v[0]*deltat;
			if(deltat != temp_t){
			temp = sys->p[i]->v[0];
			sys->p[i]->v[0] = sys->p[j]->v[0];
			sys->p[j]->v[0] = temp;
			}

			temp_x_n[j] += sys->p[j]->v[0]*(temp_t-deltat);
			temp_x_n[i] += sys->p[i]->v[0]*(temp_t-deltat);
			}
			else
				temp_x_n[i] = sys->p[i]->x[0]+sys->p[i]->v[0]*temp_t;
			if((temp_y - temp_y_n[j])*(temp_y - temp_y_n[j]) <= 4*radius*radius) {
				if((sys->p[j]->v[1] - sys->p[i]->v[1])*(sys->p[j]->v[1] - sys->p[i]->v[1]) < 0.000001){
					if(sys->p[i]->x[1] > sys->p[j]->x[1])
						sys->p[j]->v[1] *= -1;
					else
						sys->p[i]->v[1] *= -1;
					deltat = temp_t;
				}
				else {
					if(sys->p[i]->x[1] > sys->p[j]->x[1])
						deltat = (sys->p[i]->x[1] - radius - sys->p[j]->x[1] - radius)/(sys->p[j]->v[1] - sys->p[i]->v[1]);
					else 
						deltat = (sys->p[i]->x[1] + radius - sys->p[j]->x[1] + radius)/(sys->p[j]->v[1] - sys->p[i]->v[1]);
			deltat =deltat<0.0? -deltat:deltat;
				}
			temp_y_n[j] = sys->p[j]->x[1]+sys->p[j]->v[1]*deltat;
			temp_y_n[i] = sys->p[i]->x[1]+sys->p[i]->v[1]*deltat;
			if(deltat != temp_t){
				temp = sys->p[i]->v[1];
				sys->p[i]->v[1] = sys->p[j]->v[1];
				sys->p[j]->v[1] = temp;
				}
			temp_y_n[j] += sys->p[j]->v[1]*(temp_t-deltat);
			temp_y_n[i] += sys->p[i]->v[1]*(temp_t-deltat);
			}
			else
				temp_y_n[i] = sys->p[i]->x[1]+sys->p[i]->v[1]*temp_t;
		}
		else {
				temp_x_n[i] = sys->p[i]->x[0]+sys->p[i]->v[0]*temp_t;
				temp_y_n[i] = sys->p[i]->x[1]+sys->p[i]->v[1]*temp_t;
		}
	}
  }

  for(int i=0; i<sys->n; i++){
		/* boundary checking */
	 if(temp_x_n[i] - radius < 0.0 || temp_x_n[i] + radius > 1.0) {
		  sys->p[i]->v[0] = -sys->p[i]->v[0];
	  }
	  else
	  sys->p[i]->x[0] = temp_x_n[i];

	  if(temp_y_n[i] - radius < 0.0 || temp_y_n[i] + radius > 1.0) {
		  sys->p[i]->v[1] = -sys->p[i]->v[1];
	  }
	  else
	  sys->p[i]->x[1] = temp_y_n[i];
  }
	glutPostRedisplay();

		}
	if (key == 27) {
// when receiving the escape key the function escapes
		exit(0);
	}
}

void myFrameMove() {

	glutPostRedisplay(); // forces glut to call the display function (myDisplay())
}
int main(int argc, char *argv[]) {
	srand((unsigned)time(0));

  	glutInit(&argc, argv);
  	glutInitDisplayMode(GLUT_DOUBLE | GLUT_RGB | GLUT_DEPTH);

  	viewport.w = 500;
  	viewport.h = 500;

sys = new ParticleSystem;
sys->n = 100;
sys->t = glutGet(GLUT_ELAPSED_TIME);
sys->p = new Particle_t[sys->n];
int coin = 0;
for(int i=0; i< sys->n; i++){
	sys->p[i] = new Particle;
	sys->p[i]->x = new float[2];
	sys->p[i]->v = new float[2];
	sys->p[i]->x[0] = (float) (i%10)/10.0 + 0.05;
	sys->p[i]->x[1] = (float) (i/10)/10.0 + 0.05;
	sys->p[i]->v[0] = 0.2;
	sys->p[i]->v[1] = 0.0;

	coin = rand()%2;
/*	if(coin)
		sys->p[i]->v[0] *= -1;
	coin = rand()%2;
	if(coin)
		sys->p[i]->v[1] *= -1;
*/}	
  	glutInitWindowSize(viewport.w, viewport.h);
  	glutInitWindowPosition(0, 0);
  	glutCreateWindow("Billiard Balls");

  	initScene();							// quick function to set up scene
   glutSwapBuffers();
	glutDisplayFunc(myDisplay);

	glutKeyboardFunc(processNormalKeys);
  	glutReshapeFunc(myReshape);				// function to run when the window gets resized
  	glutIdleFunc(myFrameMove);				// function to run when not handling any other task
  	glutMainLoop();							// infinite loop that will keep drawing and resizing and whatever else
 
for(int i=0; i<sys->n; i++){
	delete(sys->p[i]->x);
	delete(sys->p[i]->v);
	delete(sys->p[i]);
}
delete(sys->p);
delete(sys);

  	return 0;
}

